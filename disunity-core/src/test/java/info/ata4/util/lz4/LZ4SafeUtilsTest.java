package info.ata4.util.lz4;

import static org.mockito.AdditionalMatchers.or;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Matchers.isA;
import static org.mockito.Matchers.isNull;
import static org.powermock.api.mockito.PowerMockito.mockStatic;

import com.diffblue.deeptestutils.Reflector;
import info.ata4.util.lz4.LZ4SafeUtils.Match;
import info.ata4.util.lz4.LZ4SafeUtils;
import org.junit.Assert;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.junit.runner.RunWith;
import org.powermock.api.mockito.PowerMockito;
import org.powermock.core.classloader.annotations.PrepareForTest;
import org.powermock.modules.junit4.PowerMockRunner;

import java.lang.reflect.Array;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

@RunWith(PowerMockRunner.class)
public class LZ4SafeUtilsTest {

  @Rule public ExpectedException thrown = ExpectedException.none();

  /* testedClasses: LZ4SafeUtils */

  /*
   * Test generated by Diffblue Deeptest.This test covers `int
   * commonBytesBackward(byte [], int, int, int, int)' block 2 (line 68)
   * This test covers `int commonBytesBackward(byte [], int, int, int, int)'
   * block 3 (line 69)
   * This test covers `int commonBytesBackward(byte [], int, int, int, int)'
   * block 4 (line 69)
   * This test covers `int commonBytesBackward(byte [], int, int, int, int)'
   * block 5 (line 69)
   * This test covers `int commonBytesBackward(byte [], int, int, int, int)'
   * block 6 (line 69)
   * This test covers `int commonBytesBackward(byte [], int, int, int, int)'
   * block 7 (line 69)
   * This test covers `int commonBytesBackward(byte [], int, int, int, int)'
   * block 8 (line 70)
   * This test covers `int commonBytesBackward(byte [], int, int, int, int)'
   * block 9 (line 70)
   * This test covers `int commonBytesBackward(byte [], int, int, int, int)'
   * block 10 (line 72)
   *
   */

  @Test
  public void commonBytesBackwardInput1PositivePositiveZeroZeroOutputPositive()
      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {

    // Arrange
    final byte[] b = {(byte)127};
    final int o1 = 1;
    final int o2 = 1;
    final int l1 = 0;
    final int l2 = 0;

    // Act
    final Class<?> classUnderTest = Reflector.forName("info.ata4.util.lz4.LZ4SafeUtils");
    final Method methodUnderTest = classUnderTest.getDeclaredMethod(
        "commonBytesBackward", Reflector.forName("byte[]"), Reflector.forName("int"),
        Reflector.forName("int"), Reflector.forName("int"), Reflector.forName("int"));
    methodUnderTest.setAccessible(true);
    final int retval = (int)methodUnderTest.invoke(null, b, o1, o2, l1, l2);

    // Assert result
    Assert.assertEquals(1, retval);
  }

  /*
   * Test generated by Diffblue Deeptest.
   * This test case covers:
   *
   *  - conditional line 69 branch to line 72
   */

  @Test
  public void commonBytesBackwardInputNullPositiveZeroZeroZeroOutputZero()
      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {

    // Arrange
    final byte[] b = null;
    final int o1 = 1;
    final int o2 = 0;
    final int l1 = 0;
    final int l2 = 0;

    // Act
    final Class<?> classUnderTest = Reflector.forName("info.ata4.util.lz4.LZ4SafeUtils");
    final Method methodUnderTest = classUnderTest.getDeclaredMethod(
        "commonBytesBackward", Reflector.forName("byte[]"), Reflector.forName("int"),
        Reflector.forName("int"), Reflector.forName("int"), Reflector.forName("int"));
    methodUnderTest.setAccessible(true);
    final int retval = (int)methodUnderTest.invoke(null, b, o1, o2, l1, l2);

    // Assert result
    Assert.assertEquals(0, retval);
  }

  /*
   * Test generated by Diffblue Deeptest.This test covers `int
   * commonBytesBackward(byte [], int, int, int, int)' block 2 (line 68)
   * This test covers `int commonBytesBackward(byte [], int, int, int, int)'
   * block 3 (line 69)
   * This test covers `int commonBytesBackward(byte [], int, int, int, int)'
   * block 10 (line 72)
   *
   */

  @Test
  public void commonBytesBackwardInputNullZeroZeroZeroZeroOutputZero()
      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {

    // Arrange
    final byte[] b = null;
    final int o1 = 0;
    final int o2 = 0;
    final int l1 = 0;
    final int l2 = 0;

    // Act
    final Class<?> classUnderTest = Reflector.forName("info.ata4.util.lz4.LZ4SafeUtils");
    final Method methodUnderTest = classUnderTest.getDeclaredMethod(
        "commonBytesBackward", Reflector.forName("byte[]"), Reflector.forName("int"),
        Reflector.forName("int"), Reflector.forName("int"), Reflector.forName("int"));
    methodUnderTest.setAccessible(true);
    final int retval = (int)methodUnderTest.invoke(null, b, o1, o2, l1, l2);

    // Assert result
    Assert.assertEquals(0, retval);
  }

  /*
   * Test generated by Diffblue Deeptest.This test covers `int commonBytes(byte
   * [], int, int, int)' block 2 (line 60)
   * This test covers `int commonBytes(byte [], int, int, int)' block 3 (line
   * 61)
   * This test covers `int commonBytes(byte [], int, int, int)' block 4 (line
   * 61)
   * This test covers `int commonBytes(byte [], int, int, int)' block 5 (line
   * 61)
   * This test covers `int commonBytes(byte [], int, int, int)' block 6 (line
   * 61)
   * This test covers `int commonBytes(byte [], int, int, int)' block 8 (line
   * 62)
   * This test covers `int commonBytes(byte [], int, int, int)' block 9 (line
   * 62)
   * This test covers `int commonBytes(byte [], int, int, int)' block 10 (line
   * 64)
   *
   */

  @Test
  public void commonBytesInput1ZeroZeroPositiveOutputPositive()
      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {

    // Arrange
    final byte[] b = {(byte)0};
    final int o1 = 0;
    final int o2 = 0;
    final int limit = 1;

    // Act
    final Class<?> classUnderTest = Reflector.forName("info.ata4.util.lz4.LZ4SafeUtils");
    final Method methodUnderTest = classUnderTest.getDeclaredMethod(
        "commonBytes", Reflector.forName("byte[]"), Reflector.forName("int"),
        Reflector.forName("int"), Reflector.forName("int"));
    methodUnderTest.setAccessible(true);
    final int retval = (int)methodUnderTest.invoke(null, b, o1, o2, limit);

    // Assert result
    Assert.assertEquals(1, retval);
  }

  /*
   * Test generated by Diffblue Deeptest.This test covers `int commonBytes(byte
   * [], int, int, int)' block 2 (line 60)
   * This test covers `int commonBytes(byte [], int, int, int)' block 3 (line
   * 61)
   * This test covers `int commonBytes(byte [], int, int, int)' block 10 (line
   * 64)
   *
   */

  @Test
  public void commonBytesInputNullZeroZeroZeroOutputZero()
      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {

    // Arrange
    final byte[] b = null;
    final int o1 = 0;
    final int o2 = 0;
    final int limit = 0;

    // Act
    final Class<?> classUnderTest = Reflector.forName("info.ata4.util.lz4.LZ4SafeUtils");
    final Method methodUnderTest = classUnderTest.getDeclaredMethod(
        "commonBytes", Reflector.forName("byte[]"), Reflector.forName("int"),
        Reflector.forName("int"), Reflector.forName("int"));
    methodUnderTest.setAccessible(true);
    final int retval = (int)methodUnderTest.invoke(null, b, o1, o2, limit);

    // Assert result
    Assert.assertEquals(0, retval);
  }


  /*
   * Test generated by Diffblue Deeptest.This test covers `void copy8Bytes(byte
   * [], int, byte [], int)' block 2 (line 54)
   * This test covers `void copy8Bytes(byte [], int, byte [], int)' block 3
   * (line 54)
   * This test covers `void copy8Bytes(byte [], int, byte [], int)' block 5
   * (line 55)
   * This test covers `void copy8Bytes(byte [], int, byte [], int)' block 6
   * (line 54)
   * This test covers `void copy8Bytes(byte [], int, byte [], int)' block 7
   * (line 54)
   *
   */

  @Test
  public void copy8BytesInput4Positive4PositiveOutputArrayIndexOutOfBoundsException()
      throws Throwable {

    // Arrange
    final byte[] src = {(byte)0, (byte)0, (byte)0, (byte)0};
    final int sOff = 1;
    final byte[] dest = {(byte)0, (byte)0, (byte)0, (byte)0};
    final int dOff = 3;

    // Act
    thrown.expect(ArrayIndexOutOfBoundsException.class);
    try {
      final Class<?> classUnderTest = Reflector.forName("info.ata4.util.lz4.LZ4SafeUtils");
      final Method methodUnderTest = classUnderTest.getDeclaredMethod(
          "copy8Bytes", Reflector.forName("byte[]"), Reflector.forName("int"),
          Reflector.forName("byte[]"), Reflector.forName("int"));
      methodUnderTest.setAccessible(true);
      methodUnderTest.invoke(null, src, sOff, dest, dOff);
    } catch (InvocationTargetException ex) {
      throw ex.getCause();
    }

    // Method is not expected to return due to exception thrown
  }

  /*
   * Test generated by Diffblue Deeptest.
   * This test case covers:
   *  - conditional line 93 branch to line 98
   *  - conditional line 98 branch to line 99
   *  - conditional line 100 branch to line 100
   */

  @Test
  public void
  encodeSequenceInput3ZeroPositiveZeroPositive0PositivePositiveOutputArrayIndexOutOfBoundsException()
      throws Throwable {

    // Arrange
    final byte[] src = {(byte)1, (byte)1, (byte)1};
    final int anchor = 0;
    final int matchOff = 15;
    final int matchRef = 0;
    final int matchLen = 323;
    final byte[] dest = {};
    final int dOff = 2_147_483_646;
    final int destEnd = 1;

    // Act
    thrown.expect(ArrayIndexOutOfBoundsException.class);
    try {
      final Class<?> classUnderTest = Reflector.forName("info.ata4.util.lz4.LZ4SafeUtils");
      final Method methodUnderTest = classUnderTest.getDeclaredMethod(
          "encodeSequence", Reflector.forName("byte[]"), Reflector.forName("int"),
          Reflector.forName("int"), Reflector.forName("int"), Reflector.forName("int"),
          Reflector.forName("byte[]"), Reflector.forName("int"), Reflector.forName("int"));
      methodUnderTest.setAccessible(true);
      methodUnderTest.invoke(null, src, anchor, matchOff, matchRef, matchLen, dest, dOff, destEnd);
    } catch (InvocationTargetException ex) {
      throw ex.getCause();
    }

    // Method is not expected to return due to exception thrown
  }

  /*
   * Test generated by Diffblue Deeptest.
   * This test case covers:
   *  - conditional line 93 branch to line 98
   *  - conditional line 98 branch to line 99
   *  - conditional line 100 branch to line 100
   *  - conditional line 106 branch to line 106
   */

  @Test
  public void encodeSequenceInput4PositivePositiveZeroPositive5NegativePositiveOutputLZ4Exception()
      throws Throwable {

    // Arrange
    final byte[] src = {(byte)1, (byte)1, (byte)-71, (byte)0};
    final int anchor = 3;
    final int matchOff = 78;
    final int matchRef = 0;
    final int matchLen = 323;
    final byte[] dest = {(byte)0, (byte)0, (byte)0, (byte)0, (byte)0};
    final int dOff = -1;
    final int destEnd = 90;

    // Act
    thrown.expect(info.ata4.util.lz4.LZ4Exception.class);
    try {
      final Class<?> classUnderTest = Reflector.forName("info.ata4.util.lz4.LZ4SafeUtils");
      final Method methodUnderTest = classUnderTest.getDeclaredMethod(
          "encodeSequence", Reflector.forName("byte[]"), Reflector.forName("int"),
          Reflector.forName("int"), Reflector.forName("int"), Reflector.forName("int"),
          Reflector.forName("byte[]"), Reflector.forName("int"), Reflector.forName("int"));
      methodUnderTest.setAccessible(true);
      methodUnderTest.invoke(null, src, anchor, matchOff, matchRef, matchLen, dest, dOff, destEnd);
    } catch (InvocationTargetException ex) {
      throw ex.getCause();
    }

    // Method is not expected to return due to exception thrown
  }

  /*
   * Test generated by Diffblue Deeptest.
   * This test case covers:
   *  - conditional line 93 branch to line 98
   *  - conditional line 98 branch to line 102
   *  - conditional line 106 branch to line 107
   *  - conditional line 116 branch to line 119
   *  - conditional line 119 branch to line 123
   */

  @Test
  public void encodeSequenceInputNullNegativeNegativeZeroNegative2PositivePositiveOutputPositive()
      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {

    // Arrange
    final byte[] src = null;
    final int anchor = -2_147_482_629;
    final int matchOff = -2_147_482_631;
    final int matchRef = 0;
    final int matchLen = -2_147_483_513;
    final byte[] dest = {(byte)0, (byte)0};
    final int dOff = 1;
    final int destEnd = 16_777_224;

    // Act
    final Class<?> classUnderTest = Reflector.forName("info.ata4.util.lz4.LZ4SafeUtils");
    final Method methodUnderTest = classUnderTest.getDeclaredMethod(
        "encodeSequence", Reflector.forName("byte[]"), Reflector.forName("int"),
        Reflector.forName("int"), Reflector.forName("int"), Reflector.forName("int"),
        Reflector.forName("byte[]"), Reflector.forName("int"), Reflector.forName("int"));
    methodUnderTest.setAccessible(true);
    final int retval = (int)methodUnderTest.invoke(null, src, anchor, matchOff, matchRef, matchLen,
                                                   dest, dOff, destEnd);

    // Assert result
    Assert.assertEquals(2, retval);
  }

  /*
   * Test generated by Diffblue Deeptest.
   * This test case covers:
   *  - conditional line 93 branch to line 98
   *  - conditional line 98 branch to line 102
   *  - conditional line 106 branch to line 107
   *  - conditional line 116 branch to line 117
   */

  @Test
  public void
  encodeSequenceInputNullNegativeNegativeZeroPositive3NegativePositiveOutputLZ4Exception()
      throws Throwable {

    // Arrange
    final byte[] src = null;
    final int anchor = -2_147_482_631;
    final int matchOff = -2_147_482_631;
    final int matchRef = 0;
    final int matchLen = 536_870_916;
    final byte[] dest = {(byte)0, (byte)0, (byte)0};
    final int dOff = -1;
    final int destEnd = 8;

    // Act
    thrown.expect(info.ata4.util.lz4.LZ4Exception.class);
    try {
      final Class<?> classUnderTest = Reflector.forName("info.ata4.util.lz4.LZ4SafeUtils");
      final Method methodUnderTest = classUnderTest.getDeclaredMethod(
          "encodeSequence", Reflector.forName("byte[]"), Reflector.forName("int"),
          Reflector.forName("int"), Reflector.forName("int"), Reflector.forName("int"),
          Reflector.forName("byte[]"), Reflector.forName("int"), Reflector.forName("int"));
      methodUnderTest.setAccessible(true);
      methodUnderTest.invoke(null, src, anchor, matchOff, matchRef, matchLen, dest, dOff, destEnd);
    } catch (InvocationTargetException ex) {
      throw ex.getCause();
    }

    // Method is not expected to return due to exception thrown
  }

  /*
   * Test generated by Diffblue Deeptest.
   * This test case covers:
   *  - conditional line 93 branch to line 98
   *  - conditional line 98 branch to line 102
   *  - conditional line 106 branch to line 107
   *  - conditional line 116 branch to line 119
   *  - conditional line 119 branch to line 120
   */

  @Test
  public void encodeSequenceInputNullNegativeNegativeZeroPositive3PositivePositiveOutputPositive()
      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {

    // Arrange
    final byte[] src = null;
    final int anchor = -2_147_482_629;
    final int matchOff = -2_147_482_631;
    final int matchRef = 0;
    final int matchLen = 19;
    final byte[] dest = {(byte)0, (byte)0, (byte)0};
    final int dOff = 1;
    final int destEnd = 16_777_224;

    // Act
    final Class<?> classUnderTest = Reflector.forName("info.ata4.util.lz4.LZ4SafeUtils");
    final Method methodUnderTest = classUnderTest.getDeclaredMethod(
        "encodeSequence", Reflector.forName("byte[]"), Reflector.forName("int"),
        Reflector.forName("int"), Reflector.forName("int"), Reflector.forName("int"),
        Reflector.forName("byte[]"), Reflector.forName("int"), Reflector.forName("int"));
    methodUnderTest.setAccessible(true);
    final int retval = (int)methodUnderTest.invoke(null, src, anchor, matchOff, matchRef, matchLen,
                                                   dest, dOff, destEnd);

    // Assert result
    Assert.assertEquals(3, retval);
  }

  /*
   * Test generated by Diffblue Deeptest.
   * This test case covers:
   *  - conditional line 93 branch to line 94
   */

  @Test
  public void
  encodeSequenceInputNullPositiveNegativePositivePositiveNullPositivePositiveOutputLZ4Exception()
      throws Throwable {

    // Arrange
    final byte[] src = null;
    final int anchor = 57_337;
    final int matchOff = -2_147_426_278;
    final int matchRef = 2_146_951_194;
    final int matchLen = 512;
    final byte[] dest = null;
    final int dOff = 2_147_483_616;
    final int destEnd = 39;

    // Act
    thrown.expect(info.ata4.util.lz4.LZ4Exception.class);
    try {
      final Class<?> classUnderTest = Reflector.forName("info.ata4.util.lz4.LZ4SafeUtils");
      final Method methodUnderTest = classUnderTest.getDeclaredMethod(
          "encodeSequence", Reflector.forName("byte[]"), Reflector.forName("int"),
          Reflector.forName("int"), Reflector.forName("int"), Reflector.forName("int"),
          Reflector.forName("byte[]"), Reflector.forName("int"), Reflector.forName("int"));
      methodUnderTest.setAccessible(true);
      methodUnderTest.invoke(null, src, anchor, matchOff, matchRef, matchLen, dest, dOff, destEnd);
    } catch (InvocationTargetException ex) {
      throw ex.getCause();
    }

    // Method is not expected to return due to exception thrown
  }

  /*
   * Test generated by Diffblue Deeptest.
   * This test case covers:
   *  - conditional line 134 branch to line 138
   *  - conditional line 138 branch to line 142
   *  - conditional line 145 branch to line 146
   */
  @PrepareForTest({LZ4SafeUtils.class, System.class})
  @Test
  public void lastLiteralsInput0ZeroZero1ZeroPositiveOutputPositive()
      throws Exception, NoSuchMethodException, IllegalAccessException, InvocationTargetException {

    // Setup mocks
    mockStatic(System.class);

    // Arrange
    final byte[] src = {};
    final int sOff = 0;
    final int srcLen = 0;
    final byte[] dest = {(byte)0};
    final int dOff = 0;
    final int destEnd = 1;

    // Act
    final Class<?> classUnderTest = Reflector.forName("info.ata4.util.lz4.LZ4SafeUtils");
    final Method methodUnderTest = classUnderTest.getDeclaredMethod(
        "lastLiterals", Reflector.forName("byte[]"), Reflector.forName("int"),
        Reflector.forName("int"), Reflector.forName("byte[]"), Reflector.forName("int"),
        Reflector.forName("int"));
    methodUnderTest.setAccessible(true);
    final int retval = (int)methodUnderTest.invoke(null, src, sOff, srcLen, dest, dOff, destEnd);

    // Assert result
    Assert.assertEquals(1, retval);
  }

  /*
   * Test generated by Diffblue Deeptest.
   * This test case covers:
   *  - conditional line 134 branch to line 135
   */

  @Test
  public void lastLiteralsInput0ZeroZero1ZeroZeroOutputLZ4Exception() throws Throwable {

    // Arrange
    final byte[] src = {};
    final int sOff = 0;
    final int srcLen = 0;
    final byte[] dest = {(byte)0};
    final int dOff = 0;
    final int destEnd = 0;

    // Act
    thrown.expect(info.ata4.util.lz4.LZ4Exception.class);
    try {
      final Class<?> classUnderTest = Reflector.forName("info.ata4.util.lz4.LZ4SafeUtils");
      final Method methodUnderTest = classUnderTest.getDeclaredMethod(
          "lastLiterals", Reflector.forName("byte[]"), Reflector.forName("int"),
          Reflector.forName("int"), Reflector.forName("byte[]"), Reflector.forName("int"),
          Reflector.forName("int"));
      methodUnderTest.setAccessible(true);
      methodUnderTest.invoke(null, src, sOff, srcLen, dest, dOff, destEnd);
    } catch (InvocationTargetException ex) {
      throw ex.getCause();
    }

    // Method is not expected to return due to exception thrown
  }

  /*
   * wildArraycopy(byte [], int, byte [], int, int)' block 5 (line 82)
   * This test covers `void wildArraycopy(byte [], int, byte [], int, int)'
   * block 8 (line 84)
   * This test covers `void wildArraycopy(byte [], int, byte [], int, int)'
   * block 9 (line 85)
   * This test covers `void wildArraycopy(byte [], int, byte [], int, int)'
   * block 10 (line 85)
   * This test covers `void wildArraycopy(byte [], int, byte [], int, int)'
   * block 11 (line 85)
   * This test covers `void wildArraycopy(byte [], int, byte [], int, int)'
   * block 12 (line 85)
   * This test covers `void wildArraycopy(byte [], int, byte [], int, int)'
   * block 13 (line 85)
   * This test covers `void wildArraycopy(byte [], int, byte [], int, int)'
   * block 14 (line 85)
   * This test covers `void wildArraycopy(byte [], int, byte [], int, int)'
   * block 15 (line 85)wildArraycopyInput5PositiveNullPositivePositiveOutputNullPointerException
   * This test covers `void wildArraycopy(byte [], int, byte [], int, int)'
   * block 16 (line 85)
   *
   */

  @Test
  public void wildArraycopyInput5Positive3NegativePositiveOutputLZ4Exception() throws Throwable {

    // Arrange
    final byte[] src = {(byte)1, (byte)1, (byte)1, (byte)1, (byte)1};
    final int sOff = 1;
    final byte[] dest = {(byte)0, (byte)0, (byte)0};
    final int dOff = -2_147_483_456;
    final int len = 1;

    // Act
    thrown.expect(info.ata4.util.lz4.LZ4Exception.class);
    try {
      final Class<?> classUnderTest = Reflector.forName("info.ata4.util.lz4.LZ4SafeUtils");
      final Method methodUnderTest = classUnderTest.getDeclaredMethod(
          "wildArraycopy", Reflector.forName("byte[]"), Reflector.forName("int"),
          Reflector.forName("byte[]"), Reflector.forName("int"), Reflector.forName("int"));
      methodUnderTest.setAccessible(true);
      methodUnderTest.invoke(null, src, sOff, dest, dOff, len);
    } catch (InvocationTargetException ex) {
      throw ex.getCause();
    }

    // Method is not expected to return due to exception thrown
  }

  /*
   * Test generated by Diffblue Deeptest.This test covers `void
   * wildArraycopy(byte [], int, byte [], int, int)' block 5 (line 82)
   *
   */

  @Test
  public void wildArraycopyInput5PositiveNullPositivePositiveOutputNullPointerException()
      throws Throwable {

    // Arrange
    final byte[] src = {(byte)1, (byte)1, (byte)1, (byte)1, (byte)1};
    final int sOff = 1;
    final byte[] dest = null;
    final int dOff = 2_147_483_584;
    final int len = 1;

    // Act
    thrown.expect(NullPointerException.class);
    try {
      final Class<?> classUnderTest = Reflector.forName("info.ata4.util.lz4.LZ4SafeUtils");
      final Method methodUnderTest = classUnderTest.getDeclaredMethod(
          "wildArraycopy", Reflector.forName("byte[]"), Reflector.forName("int"),
          Reflector.forName("byte[]"), Reflector.forName("int"), Reflector.forName("int"));
      methodUnderTest.setAccessible(true);
      methodUnderTest.invoke(null, src, sOff, dest, dOff, len);
    } catch (InvocationTargetException ex) {
      throw ex.getCause();
    }

    // Method is not expected to return due to exception thrown
  }

  /*
   * Test generated by Diffblue Deeptest.This test covers `void
   * wildIncrementalCopy(byte [], int, int, int)' block 1 (line 47)
   *
   */

  @Test
  public void wildIncrementalCopyInputNullNegativePositivePositiveOutputNullPointerException()
      throws Throwable {

    // Arrange
    final byte[] dest = null;
    final int matchOff = -120;
    final int dOff = 2_147_483_522;
    final int matchCopyEnd = 2;

    // Act
    thrown.expect(NullPointerException.class);
    try {
      final Class<?> classUnderTest = Reflector.forName("info.ata4.util.lz4.LZ4SafeUtils");
      final Method methodUnderTest = classUnderTest.getDeclaredMethod(
          "wildIncrementalCopy", Reflector.forName("byte[]"), Reflector.forName("int"),
          Reflector.forName("int"), Reflector.forName("int"));
      methodUnderTest.setAccessible(true);
      methodUnderTest.invoke(null, dest, matchOff, dOff, matchCopyEnd);
    } catch (InvocationTargetException ex) {
      throw ex.getCause();
    }

    // Method is not expected to return due to exception thrown
  }

  /*
   * Test generated by Diffblue Deeptest.This test covers `int writeLen(int,
   * byte [], int)' block 3 (line 153)
   * This test covers `int writeLen(int, byte [], int)' block 4 (line 153)
   * This test covers `int writeLen(int, byte [], int)' block 5 (line 154)
   * This test covers `int writeLen(int, byte [], int)' block 6 (line 154)
   *
   */

  @Test
  public void writeLenInputPositive2ZeroOutputPositive()
      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {

    // Arrange
    final int len = 255;
    final byte[] dest = {(byte)0, (byte)0};
    final int dOff = 0;

    // Act
    final Class<?> classUnderTest = Reflector.forName("info.ata4.util.lz4.LZ4SafeUtils");
    final Method methodUnderTest =
        classUnderTest.getDeclaredMethod("writeLen", Reflector.forName("int"),
                                         Reflector.forName("byte[]"), Reflector.forName("int"));
    methodUnderTest.setAccessible(true);
    final int retval = (int)methodUnderTest.invoke(null, len, dest, dOff);

    // Assert result
    Assert.assertEquals(2, retval);
  }

  /*
   * Test generated by Diffblue Deeptest.This test covers `int writeLen(int,
   * byte [], int)' block 1 (line 152)
   * This test covers `int writeLen(int, byte [], int)' block 7 (line 156)
   * This test covers `int writeLen(int, byte [], int)' block 8 (line 156)
   * This test covers `int writeLen(int, byte [], int)' block 9 (line 157)
   *
   */

  @Test
  public void writeLenInputZero1ZeroOutputPositive()
      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {

    // Arrange
    final int len = 0;
    final byte[] dest = {(byte)0};
    final int dOff = 0;

    // Act
    final Class<?> classUnderTest = Reflector.forName("info.ata4.util.lz4.LZ4SafeUtils");
    final Method methodUnderTest =
        classUnderTest.getDeclaredMethod("writeLen", Reflector.forName("int"),
                                         Reflector.forName("byte[]"), Reflector.forName("int"));
    methodUnderTest.setAccessible(true);
    final int retval = (int)methodUnderTest.invoke(null, len, dest, dOff);

    // Assert result
    Assert.assertEquals(1, retval);
  }
  
}
